Подготовка к экзамену по предмету "Алгоритмические языки" 2020
=====================
#### 1. Двусвязный список: поиск элемента по значению, вставка элемента, удаление элемента. Реализация функции удаления элемента из двусвязного списка. Основные методы std::list. Пример работы с std::list
---
![list](https://prog-cpp.ru/wp-content/uploads/2014/04/DLS-add.png)

Оценки сложности (N - размер контейнера/количество элементов):
- Вставка/удаление - O(1)
- _Вставка/удаление нескольких элементов_ - O(M), где M - количество последовательных элементов, над которыми проивзодятся манипуляции.
- Поиск элемента - O(N)
- _Размер_ - O(1) после C++11, до этого O(N)
До C++11:
```cpp
/**  Returns the number of elements in the %list.  */ 
size_t size() const {
    return std::distance(begin(), end());
}
```
##### Основные методы:
- emplace/push_front (создает/копирует(перемещает) элемент в начало списка)
- emplace/push_back (создает/копирует(перемещает) элемент в конец списка)
- emplace/insert (создает/копирует(перемещает) элемент в указанную позицию)
- pop_back, pop_front, erase, clear (удаление с конца, с начала, удаление с известной позиции или промежутка, удаление всех элментов(size = 0))
- swap (Обменивает содержимое контейнера с контейнером x)
##### Основные операции:
- remove - удаляет элементы сравнимые с передаваемым значением (то есть по значение, а не по позиции)
- sort - сортирует элементы списка (по умолчанию в порядке возрастания)
- reverse - меняет порядок элементов в списке
- splice - переносит элементы из одного списка в другой с указанной позиции (второй список становиться пустым)
```cpp
// mylist1: 1 2 3 4
// mylist2: 10 20 30
it = mylist1.begin();
++it;       
mylist1.splice (it, mylist2);
// mylist1: 1 10 20 30 2 3 4
// mylist2 (empty)
// "it" still points to 2 (the 5th element)
```
- merge - слияние двух отсортированных списков, второй список остается пустым.

##### Реализация функции удаления:
Если элемент не является концом или началом, очищаем память и перезаписываем значение предыдущего и следующего значения. В случае конца удаляем элемент и предыдущий элемент указывает на nullptr
В случае начала удаляем первый элемент и указатель следующего указывает на nullptr
```cpp
template <typename T>
iterator list<T>::erase(iterator elem) {
  if (elem == end()) return elem;                 // Check if dereferenceble
  if (elem->prev) elem->prev->next = elem->next;  // Check if prev element exists
  else first = elem->next;                        // otherwise change list first elem
  if (elem->next) elem->next->prev = elem->prev;  // Check if next element exists
  else last = elem->prev;                         // otherwise change list last elem
  auto old = elem++;                              // Increment elem and save old iterator to delete its pointer later
  delete old.base();
  return elem;
}
```

#### 2. Класс std::map. Внутренняя реализация map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::map
---
![map](https://qph.fs.quoracdn.net/main-qimg-12cd34c071b5ed07220d841c3c0b2090)

Отсортированный ассоциативный контейнер, содержащий пары ключ-значение с уникальными ключами. Ключи отсортированы с помощью функции сравнения Compare. Операции поиска, удаления и вставки имеют логарифмическую сложность. Карты обычно реализованы в виде красно-черных деревьев.

Красно-черное дерево - это бинарное дерево поиска с дополнительным параметром цветом в каждом узле. В соответствии с накладываемыми на узлы дерева ограничения ни один простой путь от корня в КЧД не отличается от другого по длине более чем в два раза, таким образом КЧД являются приближенно сбалансированными.

```cpp
class map {
private:
    enum Color {
        RED, BLACK
    };

    struct Node {
        Node *Parent;
        Node *Left;
        Node *Right;
        Color color;
        _Key key;
        _T value;
    ...
```    
##### Основные методы:
- insert - вставка элемента/элементов. В последнем случае сложность O(N * log(size + N)). Поскольку ключи элемента в карте уникальны, операция вставки проверяет, есть ли у каждого вставленного элемента ключ, эквивалентный ключу элемента, уже находящегося в контейнере, и, если это так, элемент не вставляется, возвращая итератор.
```cpp
std::map<char,int> mymap;
// first insert function version (single parameter):
mymap.insert ( std::pair<char,int>('a',100) );
mymap.insert ( std::pair<char,int>('z',200) );

std::pair<std::map<char,int>::iterator,bool> ret;
ret = mymap.insert ( std::pair<char,int>('z',500) );
if (ret.second==false) {
    std::cout << "element 'z' already existed";
    std::cout << " with a value of " << ret.first->second << '\n';
}

// second insert function version (with hint position):
std::map<char,int>::iterator it = mymap.begin();
mymap.insert (it, std::pair<char,int>('b',300));  // max efficiency inserting
mymap.insert (it, std::pair<char,int>('c',400));  // no max efficiency inserting

// third insert function version (range insertion):
std::map<char,int> anothermap;
anothermap.insert(mymap.begin(),mymap.find('c'));

// showing contents:
std::cout << "mymap contains:\n";
for (it=mymap.begin(); it!=mymap.end(); ++it)
    std::cout << it->first << " => " << it->second << '\n';

std::cout << "anothermap contains:\n";
for (it=anothermap.begin(); it!=anothermap.end(); ++it)
    std::cout << it->first << " => " << it->second << '\n';
```
Вывод
```
element 'z' already existed with a value of 200
mymap contains:
a => 100
b => 300
c => 400
z => 200
anothermap contains:
a => 100
b => 300
```
- emplace - Вставляет новый элемент в карту, если его ключ уникален. Этот новый элемент создается на месте, а не копируется или перемещается.
```cpp
std::map<char, int> mymap;
mymap.emplace('a', 1);
mymap.emplace('b', 2);
```
- erase - удаление элемента по ключу, по итератору или в диапозоне.
```cpp
std::map<char, int> mymap;
mymap['a'] = 1;
mymap['b'] = 2;
mymap.erase('a');
```
- swap - обменивает содержимое контейнера на содержимое x , который является другой картой того же типа. Размеры могут отличаться.
- clear - удаление всех элементов из карты.
- find - ищет в контейнере элемент с указанным ключем, возвращает итератор на найденный элемент. (Если ключа нет возвращает end())

##### Оценка сложности:
- Вставка/удаление - O(log N)
- Поиск элемента по ключу - O(log N)

#### 3. Класс std::set. Внутренняя реализация set, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::set
---
![set](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/500px-Red-black_tree_example.svg.png)

std::set - множество. Элементы уникальны, а так же сравниваются и сортируются при добавлении. Чаще всего реализовано так же как и std::map с помощью красно-черных деревьев.
##### Основные методы:
- insert
- erase
- swap
- clear
- emplace
- find

###### Сложность такая же как и у std::map в силу использования одинаковой структуры данных

###### Пример работы:
```cpp
std::set<int> myset;
std::set<int>::iterator it;
std::pair<std::set<int>::iterator,bool> ret;

// set some initial values:
for (int i=1; i<=5; ++i) myset.insert(i*10);    // set: 10 20 30 40 50

ret = myset.insert(20);               // no new element inserted

if (ret.second==false) it=ret.first;  // "it" now points to element 20

myset.insert (it,25);                 // max efficiency inserting
myset.insert (it,24);                 // max efficiency inserting
myset.insert (it,26);                 // no max efficiency inserting

int myints[]= {5,10,15};              // 10 already in set, not inserted
myset.insert (myints,myints+3);       // myset: 5 10 15 20 24 25 26 30 40 50

myset.erase(10); // myset: 5 15 20 24 25 26 30 50
it = myset.begin();
it ++;

myset.erase(it); // myset: 5 20 24 25 26 30 50
it = myset.find(25);
myset.erase(it, myset.end()); // myset: 5 20 24

std::set<int> myset2 {1, 2, 3};
myset2.emplace(4);

myset1.swap(myset2)
```

#### 4. Класс std::unordered_map. Внутренняя реализация unordered_map, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std:: unordered_map
---
unordered_map - является ассоциативным контейнером, который содержит пары ключ-значение с уникальными ключами. Поиск, вставка и удаление выполняются за константное время. 
Внутренне unordered_map реализована с использованием хэш-таблицы, ключ хэшируется в индексы хэш-таблицы, поэтому производительность структуры данных во многом зависит от хэш-функции, но в среднем вставка и удаление из хэш-таблицы составляет О(1).
![hash_table](http://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/HASHTB08.svg/362px-HASHTB08.svg.png)

##### Основные методы:
- emplace
- emplace_hint (hint - итератор используемый в качестве предположения о позиции, в которую нужно вставить новый элемент)
```cpp
template <class... Args>
iterator emplace_hint (const_iterator hint, Args&&... args );
```
- insert
- erase
- clear
- swap
- find

#### 5. Класс std::vector. Внутренняя реализация vector, его основные методы. Сложность поиска, сортировки, удаления элемента, добавления элемента. Пример работы с std::vector. Особенность std::vector<bool>.
---
std :: vector - динамический массив. Как и массивы, используются последовательные участки памяти для своих элементов, это также означает, что они могут быть использованы как в массиве по указателю, так и по распределенному указателю. Размер может изменяться автоматически, а размер автоматически обрабатывается контейнером.
    
![vector](https://qph.fs.quoracdn.net/main-qimg-d2696c877d001f9e11c316bc1c5412ac)    
##### Основные методы:
- emplace - создание и вставка элемента на заданную позицию (О(n)).
- emplace_back - создание и вставка в конец (O(1)).
- push_back - вставка элемента в конец (О(1)).
- insert - вставка элемента в указанную позицию (O(n)).
- swap - обмен содержимым с другим вектором (О(n)).
- erase - удаление элемента с указанной позиции или элементов из диапазона (O(n)).
- clear - удаление всех элементов вектора (O(n)).

- size - возвращает размер вектора (O(n)).
- resize - изменяет размер вектора (O(n)).
- capacity - возвращает количество элементов, на которые хватит зарезервированной памяти.
- reserve - резервирует области памяти для указанного количества элементов.

##### Особенности std::vector<bool>:
специализация std::vector, более эффективно использующая память путем храненения булевых значений в каждом бите (в отличие от одного значения в байте, как для переменных типа bool). Так же предоставляет особый метод - flip, для инвертирования всех значений массива.

#### 6. Парадигмы ООП. Полиморфизм (статический, динамический). Инкапсуляция. Наследование. Примеры.
---
ООП - методология программирования, в которой основными концепциями являются понятия объектов и классов. В центре ООП находится понятие объекта и данных. Парадигмы ООП: полиморфизм, наследование и инкапсуляция.

_Инкапсуляция_ - сокрытие информации, которое гарантирует что данные объекта и его методы используются по назначению. Использование инкапсуляции позволяет в дальнейшем изменять устройство классов без вреда для пользователя, при условии что открытый интерфейс объекта остается неизменным. С++ предоставляет 3 типа доступа - public, protected(доступ открыт классам, производным от данного) и private(только для функций класса или для друзей класса).

_Наследование_ - базирование одного типа данных (объекта или класса) на другом типе данных, способствующее повторному использованию уже существующего кода. Помимо повторного использования кода через наследование реализуются очевидные связи между классами, что способствует чистоте кода. С++ предлагает несколько типов наследования - public, protected, private и даже виртуальное наследование (Для разрешения проблем ромбовидного наследования), каждое из которых реализует определенное отношение между классами. К примеру public наследование реализует отношение "является".

_Полиморфизм_ - различное поведение объекта в зависимости от обстоятельств. С++ допускае два типа полиморфизма. Статический (времени компиляции) и динамический (времени исполнения)

_Статический полиморфизм_ представлен перегрузкой функций, аргументами по умолчанию и шаблонами. Таким образом функция ведет себя по разному в зависимости от параметров или типа, над которыми она работает.

_Динамический полиморфизм_ представлен наследованием и виртуальными функциями. Во время выполнения определяется какой метод необходимо использовать для соответствующего объекта в иерархии.

#### 7. Разработка обобщенных типов: шаблоны С++. Инстанцирование. Спецификация шаблонов. Примеры.
---
Шаблоны - средство C++, предназначенное для разработки обобщённых алгоритмов, без привязки к некоторым параметрам (например, типам данных). Инстанцирование шаблона – это генерация кода функции или класса по шаблону для конкретных параметров.
```cpp
template <typename T> T sqr(T);
template <typename T>
class X {
  T x;
public:
  explicit X(T x):x(x){}
  T get()const;
  void set(T);
};
```
```cpp
#include "my.h"
template <typename T>
T sqr(T x){
    return x*x;
}
template <typename T>
T X<T>::get() const {
    return x;
}
template <typename T>
void X<T>::set(T x) {
    this->x=x;
}
template double sqr(double); // явное инстанцирование шаблона функции
template int sqr(int);       // для двух типов аргументов
template class X<int>;       // и класса для типа int
```
```cpp
#include <iostream>
#include "my.h"
using namespace std;
int main()
{
  cout<<sqr(10)<<"\n";  // OK
  cout<<sqr(1.2)<<"\n"; // OK
  cout<<sqr(10L)<<"\n"; // Ошибка, нет sqr(long)
  
  X<int> x1(10); 
  cout<<x1.get()<<"\n"; // OK
  X<double> x2(1.2); 
  cout<<x2.get()<<"\n"; // Ошибка, нет X<double>::get()
  return 0;
}
```
Специализация - ручное указание реализации сущности для каких-либо конкретных параметров. Может быть полной или частичной.
```cpp
// Сама шаблонная функция. На ее месте может быть и класс
template <typename T1, typename T2>
void foo() {}

// Полная специализация
template <>
void foo<int, int>() {}

// Частичная специализация
template <typename T>
void foo<int, T>() {}
```
#### 8. Итераторы: определение, назначение, преимущества. Итераторы прямого доступа, итераторы ввода, итераторы вывода, двунаправленные итераторы, прямой итератор. Примеры.
---
Итераторы обеспечивают доступ к элементам контейнера. С помощью итераторов очень удобно перебирать элементы. Итератор описывается типом iterator. Но для каждого контейнера конкретный тип итератора будет отличаться. Так, итератор для контейнера list<int> представляет тип list<int>::iterator, а итератор контейнера vector<int> представляет тип vector<int>::iterator и так далее.
    
Для получения итераторов контейнеры в C++ обладают такими функциями, как begin() и end(). Функция begin() возвращает итератор, который указывает на первый элемент контейнера (при наличии в контейнере элементов). Функция end() возвращает итератор, который указывает на следующую позицию после последнего элемента, то есть по сути на конец контейнера. Если контейнер пуст, то итераторы, возвращаемые обоими методами begin и end совпадают. Если итератор begin не равен итератору end, то между ними есть как минимум один элемент.

С итераторами можно проводить следующие операции:
- *iter: получение элемента, на который указывает итератор
- ++iter: перемещение итератора вперед для обращения к следующему элементу
- --iter: перемещение итератора назад для обращения к предыдущему элементу. Итераторы контейнера forward_list не поддерживают операцию декремента.
- iter1 == iter2: два итератора равны, если они указывают на один и тот же элемент
- iter1 != iter2: два итератора не равны, если они указывают на разные элементы

_Итераторы ввода_ - итераторы, который перемещается только в одном направлении и поддерживает только чтение.
_Итераторы вывода_ - итераторы, допускающие запись и единичный проход в одном направлении.
_Итераторы прямого доступа_ - итератор, дополнительно к свойствам предыдущих двух, допускающий множественный проход в одном направлении.
_Двунаправленные итераторы_ - итератор, допускающий проход в обоих направлениях.
_Итератор произвольного доступа_ - итератор, допускающий произвольный доступ (арифметика указателей, доступная указателям в массивах).
![iterators](https://github.com/sergejkoll/exam-preparation/blob/master/images/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202020-01-06%2013-25-01.png)
#### 9. Современный С++: auto, decltype, range base loop, nullptr, constexpr, enum class, if constexpr.
---
_auto_ - в С++11 auto позволяет не указывать тип переменной явно, говоря компилятору, чтобы он сам определил фактический тип переменной, на основе типа инициализируемого значения, так же  вы можете использовать auto вместо типа возвращаемого значения функции.
_decltype_ - возвращает тип заданного выражения.
```cpp
const int&& foo();
auto i = foo(); //  i будет иметь тип int
dectype(auto) i2 = foo(); //  i2 будет иметь тип const int&&
```
###### пример
```cpp
int foo();
int& foo1();
const int foo2();
const int& foo3();

int main()
{
  auto ri = foo(); // int
  auto ri1 = foo1(); // int
  auto ri2 = foo2(); // int
  auto ri3 = foo3(); // int

  auto& ri4 = foo(); // Не скомпилируется
  auto& ri5 = foo1(); // int&
  auto& ri6 = foo2(); // Не скомпилируется
  auto& ri7 = foo3(); // const int&

  auto&& ri8 = foo(); // int&&
  auto&& ri9 = foo1(); // int&
  auto&& ri10 = foo2(); // const int&&
  auto&& ri11 = foo3(); // const int&

  int k = 5;
  decltype(k)&& rk = k; // Не скомпилируется
  decltype(foo())&& ri12 = foo(); // int&&
  decltype(foo1())&& ri13 = foo1(); // int&
  
  int i = 3;
  decltype(i) ri14; // int
  decltype((i)) ri15; // int&
}
```
_Range-based for loop_ - Выполняет цикл для диапазона. Используется в качестве более удобочитаемого эквивалента традиционному циклу for, работающему в диапазоне значений, таких как все элементы в контейнере.
```cpp
std::vector<int> v =  {0, 1, 2, 3, 4, 5};
for (const int& i : v)  // доступ по константной ссылке 
    std :: cout << i << ' ';
for (auto i : v) // доступ по значению, тип i - int 
    std::cout << i << ' '; 
```
_nullptr_ - нулевое значение указателя (является константой r-value)
```cpp 
int *ptr = nullptr;
```
_constexpr_ - c помощью этого спецификатора можно создавать переменные, функции и даже объекты, которые будут рассчитаны на этапе компиляции. (Спецификатор constexpr введен для того, чтобы заставить компилятор на этапе кмпиляции создавать объекты и использовать их как константы времени компиляции.)
```cpp
constexpr int sum (int a, int b)
{
	return a + b;
}

void func()
{
	constexpr int c = sum (5, 12); // значение переменной будет посчитано на этапе компиляции
}
```
```cpp
struct A {
    constexpr static double x = 10.0;
    //const static double x = 10.0 - не скомпилируется
};

int main() {
    A a;
    return 0;
}
```
_enum class_ - перечисления с областью видимости
```cpp
enum Fruits {
    LEMON,
    KIWI
};

enum class Colors {
    PINK,
    GREY,
};

Fruits fruit = LEMON;
Colors color = Colors::PINK;
```
_if constexpr_ - if во время компиляции.
```cpp
template <typename T>
std::string str(T t) {
  if constexpr (std::is_same_v<T, std::string>) // строка или преобразуемый в строку
    return t;
  else
    return std::to_string(t);
}
```
#### 10. Современный С++: static_assert, initializer_list, default, final, override, using
---
_Стейтмент assert_ (или ещё «оператор проверочного утверждения») в C++ — это макрос препроцессора, который обрабатывает условное выражение во время выполнения. 
_static_assert_ - во время компиляции. (Поскольку static_assert не обрабатывается во время выполнения, то стейтменты static_assert могут быть размещены в любом месте кода (даже в глобальном пространстве))
```cpp
static_assert(sizeof(long) == 8, "long must be 8 bytes");
static_assert(sizeof(int) == 4, "int must be 4 bytes");
```
_initializer_list_ - список инициализации
```cpp
class ArrayInt {
///
ArrayInt(const std::initializer_list<int> &list) : ArrayInt(list.size()) // позволяем инициализацию ArrayInt через список инициализации
{
    // Инициализация нашего начального массива значениями из списка инициализации
    int count = 0;
    for (auto &element : list) {
        m_data[count] = element;
	++count;
    }
}
///
int main()
{
    ArrayInt array { 7, 6, 5, 4, 3, 2, 1 }; // список инициализации
    for (int count = 0; count < array.getLength(); ++count)
	std::cout << array[count] << ' ';

    return 0;
}
```
 _default_ - суть спецификатора заключается в том, что пользователь может указать компилятору реализовать ту или иную функцию-член класса по-умолчанию.(применим только к конструкторам, деструктору и оператору присваивания/перемещения)
```cpp
class Foo
{
public:
    Foo() {} // Foo() = default;
    Foo(int x) {/* ... */}
};
```
_final_ - С++11 позволяет запрещать в классах-наследниках переопределение определенных методов. Достигается это за счет применения спецификатора final рядом с сигнатурой метода.
```cpp
class Base
{
public:
    virtual void doSomething(int x) final;
};
// ...
class Derived : public Base
{
public:
    virtual void doSomething(int x); // ошибка!
};
```
_override_ - компилятор, обнаружив override, проверяет существование метода с данной сигнатурой в базовом классе. Если же такого метода нет — выдает ошибку.
```cpp
class Base
{
public:
    virtual void doSomething(int x);
};
// ...
class Derived : public Base
{
public:
    virtual void doSomething(long x) override;
};
```
_using_ - используется для создания псевдонимов типа данных.
```cpp
using iterator = typename std::vector<value_type>::iterator;
```
#### 11. Современный С++: std::optional, std::variant, std::any, std::string_view. Примеры использования
---
- Класс ```std::optional``` управляет опциональным значением, т. е. значением, которое может присутствовать или отсутствовать.
```cpp
std::optional<int> TryParseNumber(const std::string& str);

auto num = TryParseNumber("123");
if (num) {
  std::cout << num.value(); // или *num;
}
std::cout << num.value_or(0);

auto num = TryParseNumber("Not number");
if (num) {
  std::cout << num.value(); // или *num;
}
std::cout << num.value_or(0);
```
- Класс std::variant представляет собой типобезопасное объединение (union).
```cpp
std::variant<int, float> v;
v = 12
int a = std::get<int>(v);
int b = std::get<0>(v);
 
try {
    std::get<float>(v);
}
catch (const std::bad_variant_access&) {}
```

- Класс ```std::any``` – типобезопасносный контейнер для одиночного значения любого типа.
```cpp
std::any value;
 
value = 1;
value = std::string("Something");
value = Student{"Ivanov", "BMSTU", 2019};
std::string name = std::any_cast<Student>(value).Name;
```

```std::string_view``` - это класс, не владеющий строкой, но хранящий указатель на начало строки и её размер. Таким образом мы не владеем строкой а имеем "право просмтора"
```cpp
// C++11
#include <string>
void get_vendor_from_id(const std::string& id) { // аллоцирует память, если большой массив символов передан на вход вместо std::string
    std::cout <<
        id.substr(0, id.find_last_of(':')); // аллоцирует память при создании больших подстрок
}
```
```cpp
// C++17
#include <string_view>
void get_vendor_from_id(std::string_view id) { // не аллоцирует память, работает с `const char*`, `char*`, `const std::string&` и т.д.
    std::cout <<
        id.substr(0, id.find_last_of(':')); // не аллоцирует память для подстрок
}
```

#### 12. Лямбда-функции, функторы, указатели на функции, std::functional. Примеры использования std::functional. Примеры использования лямбда-функций.
---
_Лямбда-выражениями_ называются безымянные локальные функции, которые можно создавать прямо внутри какого-либо выражения.(лямбда-выражения в C++ — это краткая форма записи анонимных функторов.) По умолчанию лямба-функции возвращают void, однако при наличии одного return в лямбда-выражении, компилятор вычисляет тип возвращаемого значения самостоятельно. Если же в лямбда-выражении присутствует if или switch (или другие сложные конструкции) то надо указывать возвращаемый тип самостоятельно ```[] (int _n) -> double```

_Захват переменных из внешнего контекста_ - в лямбда-функции так же можно передавать переменные (список захвата), но при попытке изменить захваченные переменные получим ошибку (так как по умолчанию генерируемый operator()() объявлен как const), чтобы это обойти используем ключевое слово mutable. Так же можно передавать параметры по ссылке и использовать "режими захвата" ```[=] - по значению, [&] - по ссылке``` тогда все переменные используемые в лямбда-функции захватываются по умолчанию.


_Функторы_ — это прежде всего классы с перегруженной операцией (), а потом любые объекты, которые умеют вести себя как функции: это указатели на функции, лямбда-функции и имена функций, но сами функции и ссылки на функции функторами не являются, потому что они в терминах С++ не объекты.

_Указатель на функцию_ -  по сути указатель на функцию содержит адрес первого байта в памяти, по которому располагается выполняемый код функции. (имя так же является указателем на функцию).


_std::functional_ — библиотека, предоставляющая множество стандартных функторов (i.e. std::hash, etc)

_std::function<[function_type]>_ — полиморфная обёртка для функций, функторов, лямбда-выражений, функций-членов класса, привязки выражений (std::bind) и других вызываемых сущностей

```cpp
#include <functional>
#include <iostream>
 
struct Foo {
    Foo(int num) : num_(num) {}
    void print_add(int i) const { std::cout << num_+i << '\n'; }
    int num_;
};
 
void print_num(int i)
{
    std::cout << i << '\n';
}
 
int main()
{
    // store a free function
    std::function<void(int)> f_display = print_num;
    f_display(-9);
 
    // store a lambda
    std::function<void()> f_display_42 = []() { print_num(42); };
    f_display_42();
 
    // store the result of a call to std::bind
    std::function<void()> f_display_31337 = std::bind(print_num, 31337);
    f_display_31337();
 
    // store a call to a member function
    std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;
    Foo foo(314159);
    f_add_display(foo, 1);
}
```


#### 13. R-value ссылки. Семантика перемещения. std::move, std::forward. Пример.
---
Rvalue ссылки – техническое расширение языка C++. Они позволяют компилятору определить, когда необходимо использовать перемещение, вместо копирования. Основное отличие rvalue от lvalue в том, что объекты rvalue могут быть перемещены, тогда как объекты lvalue всегда копируются.

Семантика перемещения позволяет компиляторам заменять дорогостоящие операции копирования “дешевыми” перемещениями.

```std::move()``` — это стандартная библиотечная функция, которая конвертирует передаваемый аргумент в r-value. Мы можем передать l-value в std::move(), и std::move() вернёт нам ссылку r-value.

```cpp
template<typename Т>
typename remove_reference<T>::type&&
move (T&& param) {
    using ReturnType = typename remove_reference<T>::type&&;
    return static_cast<ReturnType>(param);
}
```
Часть ```&&``` возвращаемого типа функции предполагает, что std::move возвращает rvalue-ccылкy, но, если тип т является rvаluе-ссылкой, Т&& становится lvаluе-ссылкой. Чтобы этого не произошло, к Т применяется свойство типа std::remove_reference, тем самым обеспечивая применение ```&&``` к типу, не являющемуся ссылкой. Это гарантирует, что std::move действительно возвращает rvаluе-ссылку.

```std::forward``` представляет собой условное приведение (в отличии от ```std::move```), эта функция выполняет приведение к rvalue только тогда, когда ее аргумент инициализирован rvalue. 

###### пример
```cpp
void process ( const Widget& lvalArg) ; // Обработка lvalue
void process (Widget&& rvalArg); // Обработка rvalue

template<typename Т>            // шаблон, передающий
void logAndProcess (T&& param)  // param на обработку
{
    auto now = std::chrono::system_clock::now(); // Получает текущее время
    process (std::forward<T>(param));
}

logAndProcess (w); // Вызов с lvalue
logAndProcess (std::move(w)); // Вызов с rvalue 
```

#### 14. Обработка ошибок с использованием механизма обработки исключений. RAII. Примеры классов, использующих RAII. Ключевое слово noexcept.
---
- throw генерирует исключение, затем в блок после ключевого слова try помещается код, который потенциально может сгенерировать исключение, после ключевого слова catch в скобках идет параметр, который передает информацию об исключении. Затем в блоке производится собственно обработка исключения.

- _Resource Acquisition Is Initialization_ - идиома объектно-ориентированного программирования, смысл которой заключается в том, что получение некоторого ресурса неразрывно совмещается с инициализацией объекта, а освобождение — с уничтожением. (Другими словами, выделяем память (или любой другой ресурс) в конструкторе некого объекта, а освобождаем - в деструкторе.)
```cpp
template <class T>
struct ScopedPtr {
  T* ptr_;
 
  ScopedPtr(T* ptr) {
    ptr_ = ptr;
  }
 
  ~ScopedPtr() {
    delete ptr_;
  }
};
 
ScopedPtr<Unit> guard(new Knight);
```
- noexcept - спецификатор времени компиляции, которой говорит компилятору о том, что функция не будет выбрасывать исключения.

#### 15. RAII. «Умные» указатели. std::shared_ptr. Примеры.
---
- Класс shared_ptr является указатем на объект, которым владеет сразу несколько объектов. Указатель можно как перемещать, так и копировать. Число существующих указателей отслеживается при помощи счетчика ссылок. Когда счетчик ссылок обнуляется, вызывается деструктор объекта.

```cpp
std::shared_ptr ptr(new Image("~/photo.png"));
// auto ptr = std::make_shared<Image>("~/photo.png");
 
// Copy:
std::shared_ptr another_ptr = ptr;
assert(ptr != nullptr);
assert(another_ptr != nullptr);
 
// Move:
std::shared_ptr yet_another_ptr = std::move(ptr);
assert(ptr == nullptr);
assert(yet_another_ptr != nullptr);
assert(another_ptr != nullptr);
```
- Shared и многопоточность
Подсчет ссылок в shared_ptr построен с использованием атомарного счетчика. Можно безопасно использовать указатели на один и тот же объект из разных потоков. Во всяком случае, не стоит беспокоиться о подсчете ссылок. Потокобезопасность самого объекта – другая проблема, и о ней надо заботится отдельно.

#### 16. RAII. «Умные» указатели. std::unique_ptr. Примеры.
---
- Шаблонный класс unique_ptr представляет собой уникальный указатель на объект. Указатель нельзя копировать, но можно передавать владение им с помощью std::move. При уничтожении указателя автоматически вызывается деструктор объекта, на который он указывает. Cовместим с STL-контейнерами, поддерживает custom deleter.

```cpp
std::unique_ptr ptr(new Image("~/photo.png"));
// Вызов конструктора копирования.
std::unique_ptr another_ptr = ptr; // ошибка
```
```cpp
std::unique_ptr ptr(new Image("~/photo.png"));
//std::unique_ptr ptr = std::make_unique<Image>("~/photo.png");
// Вызов конструктора перемещения.
std::unique_ptr another_ptr = std::move(ptr);
 
// |ptr| никуда не указывает.
assert(ptr == nullptr);
 
// |another_ptr| владеет объектом Image.
assert(another_ptr != nullptr);
```
- Совеместимость с STL-контейнерами.
```cpp
std::vector<std::unique_ptr> array;
array.push_back(new Image("~/photo.png"));
```

#### 17. RAII. «Умные» указатели. std::weak_ptr. Примеры.
---

Одной из проблем при работе является с ```std::shared_ptr``` является возможность создания циклической ссылки (например когда два объекта ссылаются друг на друга, таким образом счетчик не обнулится и не будет вызван деструктор -> утечки памяти).

Эту проблему можно решить при помощи использования ```std::weak_ptr``` — он может наблюдать и получать доступ к тому же объекту, на который указывает std::shared_ptr (или другой std::weak_ptr), но не считаться владельцем этого объекта.

Недостатком std::weak_ptr является то, что его нельзя использовать напрямую (нет оператора ->). Чтобы использовать std::weak_ptr, вы сначала должны конвертировать его в std::shared_ptr (с помощью метода lock()), а затем уже использовать std::shared_ptr.

```cpp
#include <memory>
#include <iostream>

class SomeClass {
public:
    void sayHello() {
        std::cout << "Hello!" << std::endl;
    }

    ~SomeClass() {
        std::cout << "~SomeClass" << std::endl;
    }
};

int main() {
    std::weak_ptr<SomeClass> wptr;

    {
        auto ptr = std::make_shared<SomeClass>();
        wptr = ptr;

        if(auto tptr = wptr.lock()) {
            tptr->sayHello();
        } else {
            std::cout << "lock() failed" << std::endl;
        }
    }

    if(auto tptr = wptr.lock()) {
        tptr->sayHello();
    } else {
        std::cout << "lock() failed" << std::endl;
    }
}
```


#### 18. Сетевое взаимодействие. Berkley sockets. Основные функции для работы с сокетами
---

Взаимодействие в сети рассматривается на основе понятия сокетов, которые позволяют приложениям рассматривать сетевые подключения как файлы, и программа может читать из сокета или писать в сокет, как она делает это с файлом. Существуют два механизма, предназначенных для сетевого взаимодействия программ, - это сокеты датаграмм, которые используют
пользовательский датаграммный протокол (User Datagram Protocol)
(UDP) без установления соединения, и сокеты, используюющие Протокол управления передачей / Межсетевой протокол (Transmission Control Protocol/Internet Protocol) (TCP/IP), устанавливающий соединение.

Для работы с сетью традиционно используются сокеты.
Сокет – это абстракция, которая позволяет работать с сетевыми ресурсами, как с файлами. Мы можем писать и читать данные из сокета почти так же, как из обычного файла.

Функция socket - создает новый сокет с заданными параметрами.
```cpp
int socket(int domain, int type, int protocol);
 
int sock_udp = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
int sock_tcp = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
```

Функция bind - связывает сокет с конкретным адресом сетевого интерфейса.
```cpp
int bind(int sockfd,
         const struct sockaddr *addr,
         socklen_t addrlen);
```
Где `sockaddr` - семейство структур, описывающих адреса (`sockaddr_in` - для сетевого взаимодействияб `sockaddr_un` для межпроцессорного):
Структура `sockaddr_in`:
```cpp
struct sockaddr_in {
    short            sin_family;   // e.g. AF_INET
    unsigned short   sin_port;     // e.g. htons(3490)
    struct in_addr   sin_addr;     // see struct in_addr, below
    char             sin_zero[8];  // zero this if you want to
};

struct in_addr {
    unsigned long s_addr;  // load with inet_aton()
};
```

Функция listen - переводит сокет в пассивный режим.
```cpp
int listen(int sockfd, int backlog);
```
Функция listen принимает дескриптор слушающего сокета и размер очереди запросов. Когда клиент пытается соединиться с сервером, его запрос ставится в очередь, так как сервер может быть занят обработкой других запросов. Если очередь заполнена, все последующие запросы будут игнорироваться.

Функция accept ожидает клиентские соединения.
```cpp
int accept(int sockfd,
           struct sockaddr *addr,
           socklen_t *addrlen);

```
В качестве аргумента функции передается дескриптор слушающего сокета.
При успешной установке соединения, для него создается новый сокет. Функция accept возвращает дескриптор этого сокета.
Если произошла ошибка соединения, то возвращается значение INVALID_SOCKET.

В структуру, на которую ссылается addr, записывается адрес сокета клиента, который установил соединение с сервером.
В переменную, адресуемую указателем addrlen, записывается размер структуры.

#### 19. Сетевое взаимодействие. Сокеты. Библиотека boost asio.
---
Взаимодействие в сети рассматривается на основе понятия сокетов, которые позволяют приложениям рассматривать сетевые подключения как файлы, и программа может читать из сокета или писать в сокет, как она делает это с файлом. Существуют два механизма, предназначенных для сетевого взаи-
модействия программ, - это сокеты датаграмм, которые используют
пользовательский датаграммный протокол (User Datagram Protocol)
(UDP) без установления соединения, и сокеты, используюющие Протокол управления передачей / Межсетевой протокол (Transmission Control Protocol/Internet Protocol) (TCP/IP), устанавливающий соединение.

Boost.Asio - кросс-платформенная С++ библиотека для программирования сетевых приложений и других низкоуровневых программ ввода/вывода.

Example:
```cpp
// Initialization
boost::system::error_code error;

boost::asio::io_service ioService{};
boost::asio::ip::tcp::socket socket{ioService, error};

...
...

// Binding to port
boost::asio::ip::tcp::endpoint endPoint{boost::asio::ip::v_4(), port};

socket.bind(endPoint, error);

...
...

// Connecting to server
socket.connect(someEndPoint, error);

...
...

// Read-write
std::string request;
request.resize(SOCKET_INPUT_BUFFER_SIZE);

socket.read_some(boost::asio::buffer(request), error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while reading from socket : " << error;
  return error;
}

std::string response = HandleRequest(request, error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while handling request : " << error;
  return error;
}

socket.write_some(boost::asio::buffer(response), error);
if (error) {
  BOOST_LOG_TRIVIAL(error) << "Error while writing to socket : " << error;
  return error;
}
```

#### 20. Переключение контекста потоков. Класс std::thread. Ключевое слово thread_local. Примеры использования std::thread.
---
_Контекст потоков_

Чтобы операционная система поддерживала многозадачность, каждый выполняемый поток должен обладать своим контекстом исполнения. Этот контекст используется для хранения данных о текущем состоянии потока: значения регистров процессора, указателя на стек данных, указатель на текущую выполняемую команду. В системе количество потоков может превышать (а на самом деле, почти всегда превышает) число ядер. И чтобы задачи могли корректно исполняться применяться механизм переключения между ними.

- ОС передает поток на исполнение ядру процессора.
- Этот поток исполняется в течение некоторого временного интервала.
- После завершения этого интервала контекст ОС переключается на другой поток.

_Переключение контекста_

 - обновляется контекст текущего потока
 - из имеющихся потоков в ОС выбирается один, который будет исполняться на процессоре
 - загружается контекст выбранного потока

Класс std::thread  применяется  для  управления  потоком  выполнения. В нем имеются средства для запуска нового потока и ожидания завершения потока, а также для идентификации потоков. Также в класс включены другие функции для управления потоком выполнения

Создание объекта типа std::thread запускает новый поток. До вызова деструктора объекта типа std::thread необходимо вызвать или метод join(), или метод detach().

Вызов метода join приведет к ожиданию завершения потока. Это значит, что до тех пор пока поток не завершит своё выполнение, основной поток не будет выполнять код находящийся после вызова метода join(). Этот метод необходимо использовать, если основному потоку необходим и важен результат выполнения дочернего потока.
Например, когда необходимо дождаться загрузки данных для дальнейшей обработки этих данных.

- ```std::thread::detach```

Вызов функции detach оставляет поток работать в фоновом режиме. Это значит, что код находящийся после вызова метода detach() может выполняться пока выполняется запущенный поток. Этот метод необходимо использовать, если основному потоку не важен результат выполнения дочернего потока. Например, отправка пользовательской статистики.

Флаг  типа  thread_local  –  основная  причина,  по  которой  мы  не  можем  использовать  для  управления  потоком  просто  класс  std::thread;  память  для  него  нужно  выделить  таким  образом,  чтобы  к  ней имел доступ как экземпляр interruptible_thread, так и вновь запущенный  поток.  Для  этого  функцию,  переданную  конструктору,  можно  специальным  образом  обернуть  перед  тем,  как  передавать  конструктору std::thread. Как это делается, показано в следующем листинге.

```cpp
class interrupt_flag{
public:
    void  set();
    bool  is_set()  const;
};
thread_local interrupt_flag this_thread_interrupt_flag;
    interruptible_thread{
    std::thread  internal_thread;
    interrupt_flag*  flag;
public:
    template<typename  FunctionType>    interruptible_thread(FunctionType  f)  {
      std::promise<interrupt_flag*> p;
      internal_thread=std::thread([f,&p]{
         p.set_value(&this_thread_interrupt_flag);
         f();
      });
      flag=p.get_future().get();
       }
      void  interrupt()  {
        if(flag)   {
          flag->set();
      }
  }
};

```

Пример использования std::thread:
```cpp
void hello() {
  std::cout << "Hello, World!";
}
 
int main() {
  std::thread th(hello);
  th.join();
}

```

#### 21 Синхронизация потоков. Состояние гонок. Классы std::mutex, std::lock_guard, std::unique_lock. Функция std::lock. Примеры использования мьютексов.
---
_Гонка за данными_

В программировании под состоянием “гонки” понимается любая ситуация, исход которой зависит от относительного порядка выполнения операций в более чем в одном потоке.

_Устранение гонок_

Гонки приводят к ошибкам в случае, если они (гонки) приводят к нарушению инвариантов.
Инвариант - утверждение о структуре данных, которое всегда должно быть истинным.


Чтобы избежать проблем с синхронизацией потоков можно использовать структуры данных без блокировки.
Т.е. изменить дизайн структуры данных и её инварианты так, чтобы модификация представляла собой последовательность неделимых изменений, каждое из которых сохраняет инварианты. Такой подход называется программированием без блокировок.

Взаимоисключающая блокировка - простейший сбособ защиты разделяемых данных.
Мьютексы - наиболее общий механизм защиты данных в С++.

```cpp
class mutex {
public:
    void lock();
    bool try_lock();
    void unlock();
    native_handle_type native_handle();
};

std::cout paper;
std::mutex mutex;
 
void WriteVerse() {
  mutex.lock();
  for (auto str : CreateVerse()) {
    paper << str;
  }
  mutex.unlock();
}
 
std::jthread Pushkin(WriteVerse);
std::jthread Lermontov(WriteVerse);
std::jthread Fet(WriteVerse);
```

Необходимо освобождать мьютекс на каждом пути выхода из функции, в том числе и при исключениях. Чтобы упростить эти операции, был создан std::lock_guard

```cpp
template <typename mutex_type>
struct lock_guard {
  explicit lock_guard( mutex_type& m );
  lock_guard( mutex_type& m, std::adopt_lock_t t );
  lock_guard( const lock_guard& ) = delete;
  // ...
};
void WriteVerse() {
  std::lock_guard<std::mutex> lk(mutex);
  for (auto str : CreateVerse()) {
    paper << str;
  }
}
```
Класс std::unique_lock обладает большей гибкостью, чем std::lock_guard.

- std::unique_lock реализует семантику перемещения
- std::unique_lock позволяет управлять ассоциированным с ним мьютексом (есть методы lock, try_lock, unlock)

Конструкторы std::unique_lock:
- конструктор с defer_lock_t не захватывает мьютекс
- конструктор с try_to_lock_t пытается захватить мьютекс с помощью функции try_lock()
- конструктор с adopt_lock_t используется в случае, если мьютекс уже захвачен текущим потоком

В С++ есть функция std::lock, которая захватывает сразу несколько мьютексов.
Если std::lock успешно захватила первый мьютекс, но во время попытки захвата второго мьютекса произошло исключение, то первый мьютекс освобождается.

#### 22. Синхронизация потоков. Состояние гонок. Классы std::recursive_mutex, boost::shared_mutex, std::unique_lock. Функция std::lock. Пример использования std::unique_lock.
---
_Гонка за данными_

В программировании под состоянием “гонки” понимается любая ситуация, исход которой зависит от относительного порядка выполнения операций в более чем в одном потоке.

_Устранение гонок_

Гонки приводят к ошибкам в случае, если они (гонки) приводят к нарушению инвариантов.
Инвариант - утверждение о структуре данных, которое всегда должно быть истинным.

Чтобы избежать проблем с синхронизацией потоков можно использовать структуры данных без блокировки.
Т.е. изменить дизайн структуры данных и её инварианты так, чтобы модификация представляла собой последовательность неделимых изменений, каждое из которых сохраняет инварианты. Такой подход называется программированием без блокировок.

Взаимоисключающая блокировка - простейший сбособ защиты разделяемых данных.

Мьютексы - наиболее общий механизм защиты данных в С++.

```
class mutex {
public:
    void lock();
    bool try_lock();
    void unlock();
    native_handle_type native_handle();
};

std::cout paper;
std::mutex mutex;
 
void WriteVerse() {
  mutex.lock();
  for (auto str : CreateVerse()) {
    paper << str;
  }
  mutex.unlock();
}
 
std::jthread Pushkin(WriteVerse);
std::jthread Lermontov(WriteVerse);
std::jthread Fet(WriteVerse);
```

Если несколько потоков только считывают данные и не модифицируют их, то гонок за данными не возникает.Поэтому иногда разумно предоставлять доступ для чтения к разделяемым данным нескольким потоком одновременно. Если же какой-то поток пытается модифицировать данные, то ему следует предоставлять монопольный доступ. Для такой ситуации существует класс shared_mutex.

В С++ есть функция std::lock, которая захватывает сразу несколько мьютексов.
Если std::lock успешно захватила первый мьютекс, но во время попытки захвата второго мьютекса произошло исключение, то первый мьютекс освобождается.

Иногда текущему потоку требуется оповестить о совершенном событии другие потоки, которым для своей работы необходимо знать об этом событии. Один из механизмов, который можно использовать для реализации такого поведения, – это std::future и std::promise. Однако, такой механизм может передавать сигнал от одного потока другому только один раз.

Класс std::recursive_mutex предоставляет базовые средства вза-имного  исключения  и  синхронизации  потоков,  применяемые  для  защиты  разделяемых  данных.  Перед  тем  как  обращаться  к  данным,  защищаемым мьютексом, этот мьютекс необходимо захватить (или заблокировать),  вызвав  функцию  lock()  или  try_lock().  В  любой  момент времени удерживать мьютекс может только один поток; если другой поток попытается захватить тот же мьютекс, то функция try_lock() вернет ошибку, а функция lock() приостановит выполнение потока.  Закончив  операции  над  разделяемыми  данными,  поток  дол-жен  вызвать  функцию  unlock(),  чтобы  освободить  мьютекс  и  дать  другим потокам возможность захватить его.Этот мьютекс называется рекурсивным, потому что поток, удержива-ющий мьютекс типа std::recursive_mutex, может снова обратиться к функции lock() или try_lock(), что приведет к увеличению счет-чика  захватов.  Никакой  другой  поток  не  сможет  захватить  этот  мью-текс,  пока  владеющий  им  поток  не  вызовет  функцию  unlock  столько  раз, сколько было успешных вызовов lock() или try_lock().

Пример с std::unique_lock
```cpp
struct Box {
    explicit Box(int num) : num_things{num} {}
 
    int num_things;
    std::mutex m;
};
 
void transfer(Box &from, Box &to, int num)
{
    // don't actually take the locks yet
    std::unique_lock<std::mutex> lock1(from.m, std::defer_lock);
    std::unique_lock<std::mutex> lock2(to.m, std::defer_lock);
 
    // lock both unique_locks without deadlock
    std::lock(lock1, lock2);
 
    from.num_things -= num;
    to.num_things += num;
 
    // 'from.m' and 'to.m' mutexes unlocked in 'unique_lock' dtors
}
 
int main()
{
    Box acc1(100);
    Box acc2(50);
 
    std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);
    std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5);
 
    t1.join();
    t2.join();
}

```

#### 23. Класс std::condition_variable. Потокобезопасные структуры данных с блокировками.
---
_Conditional Variable_

Для синхронизации логических зависимостей между потоками, которыми можно обмениваться многократно, можно использовать условные переменные. Условные переменные предоставляют простой механизм ожидания события, возникающего в другом потоке.

Проектирование  параллельных  структур  данных  с  блокировками  сводится  к  тому,  чтобы  захватить  нужный  мьютекс  при  доступе  к  данным и удерживать его минимально возможное время.

```cpp
struct empty_stack: std::exception {
    const char* what() const throw();
};
template<typename T>class threadsafe_stack{
private:
    std::stack<T>  data;
    mutable  std::mutex  m;
public:    threadsafe_stack(){}
    threadsafe_stack(const  threadsafe_stack&  other)  {
      std::lock_guard<std::mutex>  lock(other.m);
      data=other.data;
    }
    threadsafe_stack& operator=(const threadsafe_stack&) = delete;
    void  push(T  new_value)  {
      std::lock_guard<std::mutex>  lock(m);
      data.push(std::move(new_value));
      }
     std::shared_ptr<T>  pop()  {
      std::lock_guard<std::mutex>  lock(m);
      if(data.empty()) throw empty_stack();
      std::shared_ptr<T>  const  res(
          std::make_shared<T>(std::move(data.top())));
      data.pop();
      return  res;
      }

      void  pop(T&  value)  {
      std::lock_guard<std::mutex>  lock(m);
      if(data.empty())  throw  empty_stack();
      value=std::move(data.top());
      data.pop();
      }
      bool  empty()  const  {
      std::lock_guard<std::mutex>  lock(m);
      return  data.empty();
  }};
}

```

#### 24. Синхронизация потоков. Пул потоков. Класс std::condition_variable. Примеры работы с std::condition_variable.
---
  Чтобы избежать проблем с синхронизацией потоков можно использовать структуры данных без блокировки. Т.е. изменить дизайн структуры данных и её инварианты так, чтобы модификация представляла собой последовательность неделимых изменений, каждое из которых сохраняет инварианты. Такой подход называется программированием без блокировок.
  
Взаимоисключающая блокировка - простейший сбособ защиты разделяемых данных.

Мьютексы - наиболее общий механизм защиты данных в С++.

```
class mutex {
public:
    void lock();
    bool try_lock();
    void unlock();
    native_handle_type native_handle();
};

std::cout paper;
std::mutex mutex;
 
void WriteVerse() {
  mutex.lock();
  for (auto str : CreateVerse()) {
    paper << str;
  }
  mutex.unlock();
}
 
std::jthread Pushkin(WriteVerse);
std::jthread Lermontov(WriteVerse);
std::jthread Fet(WriteVerse);

```

Если несколько потоков только считывают данные и не модифицируют их, то гонок за данными не возникает. Поэтому иногда разумно предоставлять доступ для чтения к разделяемым данным нескольким потоком одновременно. Если же какой-то поток пытается модифицировать данные, то ему следует предоставлять монопольный доступ. Для такой ситуации существует класс shared_mutex.

Для такого поведения в С++ есть функция std::lock, которая захватывает сразу несколько мьютексов.
Если std::lock успешно захватила первый мьютекс, но во время попытки захвата второго мьютекса произошло исключение, то первый мьютекс освобождается.

Иногда текущему потоку требуется оповестить о совершенном событии другие потоки, которым для своей работы необходимо знать об этом событии. Один из механизмов, который можно использовать для реализации такого поведения, – это std::future и std::promise.

Однако, такой механизм позволяет может передавать сигнал от одного потока другому только один раз.

_Conditional Variable_

Для синхронизации логических зависимостей между потоками, которыми можно обмениваться многократно, можно использовать условные переменные. Условные переменные предоставляют простой механизм ожидания события, возникающего в другом потоке. Их работу удобно рассмотреть на примере шаблона паралелльного программирования Producer-Consumer.

Пример использования condition variables:
```
std::mutex m;
std::queue<std::string> queue;
std::condition_variable cv;

void Producer() {
  std::lock_guard<std::mutex> lk(m);
  queue.push(ReadMessageFromNetwork());
  cv.notify_one();
}

void Consumer() {
  std::unique_lock<std::mutex> lk(m);
 
  while(queue.empty()) {
    cv.wait(lk);
  }
 
  // Используем очередь.
  lk.unlock();
  // Продолжаем выполнения потока.
}
```

_Пул потоков_

В простейшем случае пул состоит из  фиксированного числа рабочих потоков  (обычно  равного  значению,  которое  возвращает  функция std::thread::hardware_concurrency()).  Когда  у  программы  по-является  какая-то  работа,  она  вызывает  функцию,  которая  помеща-ет  эту  работу  в  очередь.  Рабочий  поток  забирает  работу  из  очереди,  выполняет  указанную  в  ней  задачу,  после  чего  проверяет,  есть  ли  в  очереди другие работы.

#### 25. Управление потоками. Состояния гонок в интерфейсе структур данных. Класс std::future,функция std::async
---
Состояния гонок в интерфейсе стурктур данных - гонки, возникающие при обращении к объекту, в ходе которых нарушаются его инварианты. Инвариант - некое условие, выполнение которого необходимо для правильной работы струтктуры. К примеру поле size класса vector хранит количество элементов в массиве. Если это не так (допустим, произошла ошибка доступа к соотвествующему объекту и поле было изменено некорректно), то инвариант нарушен. Помимо этого Вильямс упоминает, что методы доступа и получения информации о структурах нельзя считать валидными, поскольку данные, полученные с помощью этих методов, были правильными лишь в момент их получения. То есть, после их получения и перед использованием данные могут быть изменены другим потоком.

```std::async``` - функция, позволяющая запустить выполнение операции в новом потоке. В отличие от ```std::thread```, для ```std::async``` существует способ получения возвращаемого функцией значения. async возвращает объект ```std::future```, потенциально содержащий результат выполнения операции (или исключение, в случае ошибки). 
async имеет конструктор подобный ```std::thread```, так же принимает функцию и ее аргументы. Дополнительно первым аргументом может быть указано правило запуска потока - ```std::launch::async``` или ```std::launch::deferred```. В первом случае новый поток запустится асинхронно, во втором же случае новый поток создан не будет, а результат начнет вычисляться в текущем потоке по первому запросу. Если же указаны оба флага - поведение зависит от реализации, ни одного - аналогично.

```std::future``` - обертка над реазультатом асинхронной операции. Такой объект возвращает ```std::async```.
Присутствует метод get, позволяющий получить результат, но его вызов обязан быть однократным (в противном случае - неопределенное поведение). ```std::future``` имеет метод valid, позволяющий проверить был ли получен результат. Так же имеет фунции ожидания (wait, в частности), которые испольузуются методом get если результат еще не готов.

#### 26. Атомарные операции. Классы std::atomic, std::atomic_flag. Примеры работы с std::atomic
---
Под атомарными понимаются неделимые операции. Ни из одного потока в системе невозможно увидеть, что такая операция выполнена наполовину – она либо выполнена целиком, либо не выполнена вовсе. Если операция загрузки, которая читает значение объекта, атомарна, и все операции модификации этого объекта также атомарны, то в результате загрузки будет получено либо начальное значение объекта, либо значение, сохраненное в нем после одной из модификаций.

Каждая специализация шаблона ```std::atomic``` определяет атомарный тип. Только объекты атомарных С++ типов могут безопасно использоваться в нескольких потоках одновременно. Когда один поток сохраняет данные в объекте атомарного типа, а другой хочет их прочитать, поведение программы определено стандартом.

```cpp
Typedef имя		Full specialization 
std::atomic_char 	std::atomic<char>
std::atomic_schar 	std::atomic<signed char>
std::atomic_uchar 	std::atomic<unsigned char>
std::atomic_short 	std::atomic<short>
std::atomic_ushort 	std::atomic<unsigned short>
std::atomic_int 	std::atomic<int>
std::atomic_uint 	std::atomic<unsigned int>
std::atomic_long 	std::atomic<long>

```

```std::atomic_flag``` - это по настоящему простой булевский флаг, а операции над этим типом обязаны быть свободными от блокировок, если имеется простой свободный от блокировок булевский флаг, то на его основе можно реализовать простую  блокировку и, значит, все остальные атомарные типы. 

Объект типа ```std::atomic_flag``` должен быть инициализирован значением ```ATOMIC_FLAG_INIT```.

Пример использования ```std::atomic_flag```:
```
class spinlock_mutex {
  std::atomic_flag  flag;
public: spinlock_mutex(): flag(ATOMIC_FLAG_INIT)  {}
  void  lock() {
    while(flag.test_and_set(std::memory_order_acquire));
}
  void  unlock() {
    flag.clear(std::memory_order_release);
  }
};

```

#### 27. Шаблоны проектирования: фабричный метод. Пример реализации «простой фабрики» и «фабричного метода».
---
Для того, чтобы система оставалась независимой от различных типов объектов, паттерн Factory Method использует механизм полиморфизма - классы всех конечных типов наследуют от одного абстрактного базового класса, предназначенного для полиморфного использования. В этом базовом классе определяется единый интерфейс, через который пользователь будет оперировать объектами конечных типов.

Реализация:
```cpp
class Warrior
{
  public:
    virtual void info() = 0;
    virtual ~Warrior() {}
};
  
class Infantryman: public Warrior
{
  public:
    void info() { 
      cout << "Infantryman" << endl; 
    };
};
  
class Archer: public Warrior
{
  public:
    void info() { 
      cout << "Archer" << endl; 
    };
};
  
class Horseman: public Warrior
{
  public:
    void info() { 
      cout << "Horseman" << endl; 
    };
};
  
  
// Фабрики объектов
class Factory
{
  public:
    virtual Warrior* createWarrior() = 0;
    virtual ~Factory() {}
};
  
class InfantryFactory: public Factory
{
  public:
    Warrior* createWarrior() { 
      return new Infantryman; 
    }
};
  
class ArchersFactory: public Factory
{
  public:
    Warrior* createWarrior() { 
      return new Archer; 
    }
};
  
class CavalryFactory: public Factory
{
  public:
    Warrior* createWarrior() { 
      return new Horseman; 
    }
};
  
  
// Создание объектов при помощи фабрик объектов
int main()
{
    InfantryFactory* infantry_factory = new InfantryFactory;
    ArchersFactory*  archers_factory  = new ArchersFactory ;
    CavalryFactory*  cavalry_factory  = new CavalryFactory ;
  
    vector<Warrior*> v;
    v.push_back( infantry_factory->createWarrior());
    v.push_back( archers_factory->createWarrior());
    v.push_back( cavalry_factory->createWarrior());
  
    for(int i=0; i<v.size(); i++)
        v[i]->info();
    // ...
}

```

#### 28. Шаблоны проектирования: observer. Пример реализации «обозреватель».
---
_Наблюдатель (англ. Observer)_ — поведенческий шаблон проектирования. Также известен как «подчинённые» (Dependents). Реализует у класса механизм, который позволяет объекту этого класса получать оповещения об изменении состояния других объектов и тем самым наблюдать за ними

_Observer_ — поведенческий шаблон проектирования. Реализует у класса механизм, который позволяет объекту этого класса получать оповещения об изменении состояния других объектов и тем самым наблюдать за ними.

Реализация:
```cpp
class SupervisedString;
class IObserver
{
public:
    virtual void handleEvent(const SupervisedString&) = 0;
};

class SupervisedString // Observable class
{
    string _str;
    list<IObserver*> _observers;

    void _Notify()
    {
        for(auto& observer: _observers)
        {
            observer->handleEvent(*this);
        }
    }

public:
    void add(IObserver& ref)
    {
        _observers.push_back(&ref);
    }

    void remove(IObserver& ref)
    {
        _observers.remove(&ref);
    }

    const string& get() const
    {
        return _str;
    }

    void reset(string str)
    {
        _str = str;
        _Notify();
    }
};

class Reflector: public IObserver // Prints the observed string into cout
{
public:
    virtual void handleEvent(const SupervisedString& ref)
    {
        std::cout << ref.get() << std::endl;
    }
};

class Counter: public IObserver // Prints the length of observed string into cout
{
public:
  virtual void handleEvent(const SupervisedString& ref)
  {
      std::cout << "length = " << ref.get().length() << std::endl;
  }
};

int main()
{
    SupervisedString str;
    Reflector refl;
    Counter cnt;

    str.add(refl);
    str.reset("Hello, World!");
    std::cout << endl;

    str.remove(refl);
    str.add(cnt);
    str.reset("World, Hello!");
    std::cout << endl;

    return 0;
}
```

#### 29. Асинхронное программирование. Плюсы и минусы. Сопрограммы. Функции обратного вызова.
---
Функция std::async  позволяет  запустить  асинхронную  зада-чу,  результат  которой  прямо  сейчас  не  нужен.  Но  вместо  объекта  std::thread  она  возвращает  объект  std::future  ,  который  будет  содержать возвращенное значение, когда оно станет доступно. Когда программе понадобится значение, она вызовет функцию-член get()объекта-будущего, и тогда поток будет приостановлен до готовности будущего  результата,  после  чего  вернет  значение. 

```cpp
#include <future>
#include <iostream>
int find_the_answer_to_ltuae();
void do_other_stuff();

int main() {
std::future<int> the_answer = std::async(find_the_answer_to_ltuae); 
do_other_stuff();
std::cout << ”Ответ равен “ << the_answer.get() <<std::endl;
}

```

Шаблон std::async  позволяет  передать  функции  дополнительные  параметры,  точно  так  же,  как  std::thread.  Если  первым  аргументом  является  указатель  на  функцию-член,  то  второй  аргумент  должен  содержать  объект,  от  имени  которого  эта  функция-член  вы-зывается

```cpp
struct X {
  void foo(int,std::string const&);
  std::string bar(std::string const&);
};

X x;
auto f1=std::async(&X::foo,&x,42,”hello”);  // Вызывается p->foo(42,"hello"), где p=&x
auto f2 = std::async(&X::bar,x,”goodbye”); // Вызывается tmpx.bar("goodbye"), где tmpx – копия x

```

Также можно  задать  требуемый  режим исполнения в  дополнительном  параметре  std::async  перед  вызываемой  функцией.  Этот  параметр  имеет  тип  std::launch  и  может  принимать  сле-дующие значения: std::launch::deferred – отложить вызов функции до того момента, когда будет вызвана функция-член wait() или get() объекта-будущего; std::launch::async – запускать функцию в    отдельном    потоке;    std::launch::deferred | std::launch::async – оставить решение на усмотрение реализации.

Плюсы и минусы асинхронного подхода:
  1) Безусловный плюс — это производительность. Причем она не просто в разы выше, она выше на порядки!
  2) Минус — сложный и запутанный код, который к тому же еще и сложно отлаживать.

Сопрограммы
Сопрограммы (корутины, coroutine) - это потоки исполнения кода, которые организуются поверх аппаратных (системных) потоков.
Поток исполнения кода - это последовательность операций, которые выполняются друг за другом. В нужные моменты эта последовательность может быть приостановлена, и вместо нее может начать выполняться часть другой последовательности операций. 

В отличие от системных потоков, которые переключаются системой в произвольные моменты времени (вытесняющая многозадачность), сопрограммы переключаются вручную, в местах, указанных программистом (кооперативная многозадачность). 

Обозначим операции над сопрограммой следующим образом:
```cpp
handle = spawn(СП); - запуск сопрограммы,
yield; - приостановка текущей сопрограммы,
resume(handle); - возобновление сопрограммы.
```

Возьмем две сопрограммы:
```cpp
// СП1      |  // СП2
{           |  {
  f1();     |     g1();
  f2();     |     yield;
  yield;    |     g2();
  f3();     |     g3();
  f4();     |     yield;
  yield;    |     g4();
  f5();     |     g5();
}           |  }

```
Тогда, если на одном системном потоке запустить СП1, а затем СП2, то системный поток выполнит операции в следующем детерминированном порядке:

```cpp
// Системный поток  |  Выполняемый код
c1 = spawn(СП1);    |  f1();
                    |  f2();
c2 = spawn(СП2);    |       g1();
resume(c1);         |  f3();
                    |  f4(); 
resume(c2);         |       g2();
                    |       g3();
resume(c1);         |  f5();
resume(c2);         |       g4();
                    |       g5();

```

Функции обратного вызова

Функция обратного вызова в программировании — передача исполняемого кода в качестве одного из параметров другого кода. Обратный вызов позволяет в функции исполнять код, который задаётся в аргументах при её вызове.

```cpp
/* The calling function takes a single callback as a parameter. */
void PrintTwoNumbers(int (*numberSource)(void)) {
    int val1 = numberSource();
    int val2 = numberSource();
    printf("%d and %d\n", val1, val2);
}

/* A possible callback */
int overNineThousand(void) {
    return (rand()%1000) + 9001;
}

/* Another possible callback. */
int meaningOfLife(void) {
    return 42;
}

/* Here we call PrintTwoNumbers() with three different callbacks. */
int main(void) {
    PrintTwoNumbers(&rand);
    PrintTwoNumbers(&overNineThousand);
    PrintTwoNumbers(&meaningOfLife);
    return 0;
}

```

#### 30. Атомарные операции. Классы std::atomic. Структуры данных без блокировок. Реализация lock-free stack
---
Операция в общей области памяти называется атомарной, если она завершается в один шаг относительно других потоков, имеющих доступ к этой памяти. Во время выполнения такой операции над переменной, ни один поток не может наблюдать изменение наполовину завершенным. Атомарная загрузка гарантирует, что переменная будет загружена целиком в один момент времени. Неатомарные операции не дают такой гарантии.

Каждая специализация шаблона ```std::atomic``` определяет атомарный тип. Только объекты атомарных С++ типов могут безопасно использоваться в нескольких потоках одновременно. Когда один поток сохраняет данные в объекте атомарного типа, а другой хочет их прочитать, поведение программы определено стандартом.

```cpp
Typedef имя		Full specialization 
std::atomic_char 	std::atomic<char>
std::atomic_schar 	std::atomic<signed char>
std::atomic_uchar 	std::atomic<unsigned char>
std::atomic_short 	std::atomic<short>
std::atomic_ushort 	std::atomic<unsigned short>
std::atomic_int 	std::atomic<int>
std::atomic_uint 	std::atomic<unsigned int>
std::atomic_long 	std::atomic<long>
```

Структуры данных и алгоритмы, в которые блокирующие библиотечные  функции  не  используются,  называются  неблокирующими. Чтобы  структура  данных  считалась  свободной  от  блокировок,  она  должна быть открыта для одновременного доступа со стороны сразу нескольких  потоков.

```cpp
template<typename T>class lock_free_stack {
private:
    struct node;
    struct counted_node_ptr {
        int external_count;
        node*  ptr;
    };

    struct node {
        std::shared_ptr<T> data;
        std::atomic<int> internal_count;
        counted_node_ptr next;
        explicit node(T const& data_): data(std::make_shared<T>(data_)), internal_count(0) {}
    };

    std::atomic<counted_node_ptr> head;

    void increase_head_count(counted_node_ptr& old_counter) {
        counted_node_ptr new_counter;
        do {
            new_counter = old_counter;
            ++new_counter.external_count;
        } while(!head.compare_exchange_strong(old_counter, new_counter, std::memory_order_acquire, std::memory_order_relaxed));
        old_counter.external_count = new_counter.external_count;
    }

public:
    ~lock_free_stack() {
        while(pop());
    }

    void push(T const& data)  {
        counted_node_ptr new_node;
        new_node.ptr = new node(data);
        new_node.external_count = 1;
        new_node.ptr->next = head.load(std::memory_order_relaxed);
        while(!head.compare_exchange_weak(new_node.ptr->next, new_node, std::memory_order_release, std::memory_order_relaxed));
    }

    std::shared_ptr<T> pop() {
        // Загружаем атомарно значение головы стека
        counted_node_ptr old_head = head.load(std::memory_order_relaxed);
        for(;;) {
            // Увеличиваем счетчик внешних ссылок на head
            // Устанавливаются  все  поля структуры, чтобы быть уверенным, что другой поток не изменил в промежутке указатель.
            increase_head_count(old_head);
            node* const ptr = old_head.ptr;

            // Проверка на пустой стек
            if(!ptr) {
                return std::shared_ptr<T>();
            }

            // Мы можем попытаться исключить узел из списка, выполнив compare_exchange_strong() с головным узлом head
            if(head.compare_exchange_strong(old_head, ptr->next, std::memory_order_relaxed)) {
                std::shared_ptr<T> res;
                // Если compare_exchange_strong()  возвращает  true,  то  мы  при-няли  на  себя  владение  узлом
                // И  можем  с  помощью  функции  swap() вытащить  из  него  данные,  которые  впоследствии  вернем
                res.swap(ptr->data);
                // мы исключили узел из списка, вследствие чего значение счетчика уменьшилось на 1
                // и больше не обращаемся к узлу из данного потока, что дает уменьше-ние еще на 1
                int const count_increase = old_head.external_count - 2;
                // Затем можно прибавить внешний счетчик к внутреннему с помощью атомарной операции fetch_add
                // fetch_add возвращает значение атомарной переменной до вызова
                // Если теперь счетчик ссылок стал равен нулю, то предыдущее значение
                // (то, которое возвращает fetch_add) было противоположно только что прибавленному, и тогда узел можно удалять.
                if(ptr->internal_count.fetch_add(count_increase, std::memory_order_release) == -count_increase) {
                    delete ptr;
                }
                return res;
                // Если сравнение не прошло, значит head модифицировали => начинаем заново
            } else if(ptr->internal_count.fetch_add(-1, std::memory_order_relaxed) == 1) {
                ptr->internal_count.load(std::memory_order_acquire);
                delete ptr;
            }
        }
    }
};

```
